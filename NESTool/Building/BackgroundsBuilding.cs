using ArchitectureLibrary.Model;
using NESTool.FileSystem;
using NESTool.Models;
using NESTool.Utils;
using NESTool.VOs;
using System;
using System.Collections.Generic;
using System.IO;

namespace NESTool.Building;

public static class BackgroundsBuilding
{
    public static void Execute()
    {
        ProjectModel projectModel = ModelManager.Get<ProjectModel>();

        List<FileModelVO> models = ProjectFiles.GetModels<MapModel>();

        foreach (FileModelVO item in models)
        {
            MapModel? model = item.Model as MapModel;

            string fullPath = Path.Combine(Path.GetFullPath(projectModel.Build.OutputFilePath), item.Name + ".s");

            using (StreamWriter outputFile = new(fullPath))
            {
                outputFile.WriteLine("; This file is autogenerated!");
                outputFile.Write(Environment.NewLine);
                outputFile.WriteLine($"nt_{item.Name}:");

                List<byte> serializedMap = [];

                if (model != null)
                    SerializeNametable(model, ref serializedMap);

                if (projectModel.Build.UseRLEOnMaps)
                {
                    RLE.Compress(serializedMap, out List<byte> compressedData);

                    serializedMap = compressedData;
                }

                FormatBytes(serializedMap, outputFile, 32);

                serializedMap.Clear();

                if (model != null && model.ExportAttributeTable)
                {
                    outputFile.WriteLine($"att_{item.Name}:");

                    SerializeAttributes(model, ref serializedMap);

                    if (projectModel.Build.UseRLEOnMaps)
                    {
                        RLE.Compress(serializedMap, out List<byte> compressedData);

                        serializedMap = compressedData;
                    }

                    FormatBytes(serializedMap, outputFile, 8);
                }

                if (model != null)
                    PrintMapEntities(model, item, outputFile);
            }
        }
    }

    private static void FormatBytes(List<byte> data, StreamWriter outputFile, int rowSize)
    {
        for (int i = 0; i < data.Count; i++)
        {
            if (i % rowSize == 0 && i < data.Count)
            {
                if (i > 0)
                {
                    outputFile.Write(Environment.NewLine);
                }

                outputFile.Write("    .byte ");
            }

            outputFile.Write($"${data[i]:X2}");

            if (i < data.Count - 1 && i % rowSize != rowSize - 1)
            {
                outputFile.Write(",");
            }
        }

        outputFile.Write(Environment.NewLine);
        outputFile.Write(Environment.NewLine);
    }

    private static void PrintMapEntities(MapModel model, FileModelVO item, StreamWriter outputFile)
    {
        void WriteEntityData(string entityName, int x, int y, Dictionary<string, string> properties)
        {
            // Entity ID
            outputFile.Write($"Entity_{entityName}, ");
            // X
            outputFile.Write($"${x:X2}");
            outputFile.Write(", ");
            // Y
            outputFile.Write($"${y:X2}");
        }

        if (model.Entities.Count == 0)
        {
            return;
        }

        outputFile.WriteLine($"metadata_{item.Name}:");

        foreach (Entity entity in model.Entities)
        {
            EntityModel? entityModel = ProjectFiles.GetModel<EntityModel>(entity.EntityID);

            if (entityModel == null)
                continue;

            outputFile.Write("    .byte ");

            FileModelVO? fileModel = ProjectFiles.GetFileModel(entity.EntityID);

            if (fileModel == null)
                continue;

            WriteEntityData(fileModel.Name, entity.X, entity.Y, entity.Properties);

            outputFile.Write(Environment.NewLine);
        }

        // Add always a null terminator
        outputFile.Write("    .byte $00");
        outputFile.Write(Environment.NewLine);
    }

    private static void SerializeNametable(MapModel model, ref List<byte> serializedData)
    {
        // iterate vertically
        for (int j = 0; j < 15; ++j)
        {
            // each meta tile has two rows, so we have to iterate same index twice
            for (int k = 0; k < 2; ++k)
            {
                // iterate horizontally
                for (int i = 0; i < 16; ++i)
                {
                    MapTile[] mapTile = model.AttributeTable[i + (j * 16)].MapTile;

                    if (mapTile == null)
                    {
                        continue;
                    }

                    if (string.IsNullOrEmpty(mapTile[0 + (k * 2)].BankID) ||
                        string.IsNullOrEmpty(mapTile[0 + (k * 2)].BankTileID) ||
                        string.IsNullOrEmpty(mapTile[1 + (k * 2)].BankID) ||
                        string.IsNullOrEmpty(mapTile[1 + (k * 2)].BankTileID))
                    {
                        continue;
                    }

                    SerializeMapTile(ref serializedData, mapTile[0 + (k * 2)]);
                    SerializeMapTile(ref serializedData, mapTile[1 + (k * 2)]);
                }
            }
        }

        static void SerializeMapTile(ref List<byte> serialized, MapTile mapTile)
        {
            BankModel? bank = ProjectFiles.GetModel<BankModel>(mapTile.BankID);

            if (bank == null)
            {
                serialized.Add(0);
            }
            else
            {
                byte tile = (byte)bank.GetTileIndex(mapTile.BankTileID);

                serialized.Add(tile);
            }
        }
    }

    private static void SerializeAttributes(MapModel model, ref List<byte> serializedData)
    {
        const int MaxHorizontal = 8;
        const int MaxVertical = 8;

        for (int j = 0; j < MaxVertical; ++j)
        {
            for (int i = 0; i < MaxHorizontal; ++i)
            {
                byte top_left = (byte)model.AttributeTable[0 + (i * 2 + (j * 32))].PaletteIndex;
                byte top_right = (byte)model.AttributeTable[1 + (i * 2 + (j * 32))].PaletteIndex;

                byte bottom_left = 0;
                byte bottom_right = 0;

                int bottomLeftIndex = 16 + (i * 2 + (j * 32));
                int bottomRightIndex = 17 + (i * 2 + (j * 32));

                if (bottomLeftIndex < model.AttributeTable.Length)
                {
                    bottom_left = (byte)model.AttributeTable[bottomLeftIndex].PaletteIndex;
                }

                if (bottomRightIndex < model.AttributeTable.Length)
                {
                    bottom_right = (byte)model.AttributeTable[bottomRightIndex].PaletteIndex;
                }

                // 7654 3210
                // |||| ||++- Color bits 3 - 2 for top left quadrant of this byte
                // |||| ++--- Color bits 3 - 2 for top right quadrant of this byte
                // ||++------ Color bits 3 - 2 for bottom left quadrant of this byte
                // ++-------- Color bits 3 - 2 for bottom right quadrant of this byte

                byte attribute = (byte)((bottom_right << 6) | (bottom_left << 4) | (top_right << 2) | top_left);

                serializedData.Add(attribute);
            }
        }
    }
}
